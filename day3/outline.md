# 搜索和图论算法 
by jal@webturing.com


### 经典图论

#### DFS深度优先搜索

DFS搜索是很多算法的基础，这是一个基于递归的程序，可以以非常简洁的代码实现逻辑需求。由于是递归程序，所以程序在运行的时候会用到系统提供的栈，因此当数据量过大的时候，dfs会导致栈溢出，从而引发运行错误。此时可以考虑是否能够换成BFS广搜。

##### 全排列问题

##### 迷宫搜索问题

##### 数字拆分问题

##### 二叉树的先序、中序、后序遍历

##### 图的边和节点遍历访问

##### 递归搜索

#### BFS广度优先搜索

BFS搜索也是一种非常常用、非常高效的搜索算法，它是基于队列实现的，只要所需内存在题目要求范围内，则不会有运行错误，在大数据量的图论搜索题目中，BFS比DFS更受ACMER的欢迎。

##### 迷宫问题

##### 二叉树的按层遍历

##### 图的边和节点的搜索

#### 并查集

并查集是判断集合数目和分类问题。这个算法比较容易理解，偶尔会作为其他算法的基础，如Kruscal算法，强连通分量。

#### Dijkstra算法
单源最短路径。求一个点到图中其他点的距离。是最著名的图论算法，在ACM竞赛或者是其他笔试面试题中都会被广泛考察。时间复杂度是${O(n^2)}$，通过堆优化可以降到${O((m+n)logn)}$


#### Prim算法

最小生成树算法，和Dijkstra算法原理相似，都有贪心思想，通过松弛计算出每一点下一个离他最近的点。和Dijkstra不同的地方在于Prim算法是把整个已生成的树作为源点，而Dijkstra是把起点作为源点。

#### Kruscal算法

最小生成树算法。是贪心的依次寻找每一条最小边加入到最小生成树中，但是每次要用过并查集来判断是否会构成回路。

#### Floyd算法

##### 求任意两点间最短路径
算法好理解，复杂度较高，${O(N^3)}$
##### 求最小环
最小环：从一个点出发经过至少一条边回到该点，不能重复经过某条边。路程最短的路径就是该图的最小环。
有向图的最小环非常简单：令dist[i][i]=+∞，然后Floyd求最短路就可以了。
我们通常所说的最小环都是无向图上的。
算法一：令e(u,v)表示u和v之间的边，再令DisT(u,v)表示，删除u和v之间的连边之后，u和v之间的最短路。枚举每条边用Dijkstra求最短路，用Dist(u,v) + e(u,v)更新最小环。时间复杂度：O(N^2M)。
Floyd的原理是：最外层循环开始进行k时，Dist[i][j]中存储的是从i到j“路径中所有节点的编号都小于k”的最短路径的长度。此时就可以用Dist[i][j]+e(i,k)+E(k,j)更新答案。
也就是我们在每次最外层循环开始时都枚举i、j，用“i到k、再到j、再经过编号小于k的节点从j到i的最短路径”来更新最小环。这样Floyd算法结束时，最小环也就求出来了。
for k:=1 to n do  begin     for i:=1 to k-1 do  for j:=1 to i-1 do  ans:=min(ans, dist[i][j]+e[i][k]+e[k][j]);      for i:=1 to n do  for j:=1 to n do  dist[i][j]:=min(dist[i][j], dist[i][k]+dist[k][j]);   end;

#### 欧拉回路
欧拉回路：俗称一笔画问题。从某个点出发，经过每条边一次且恰好一次然后回到该点。
欧拉回路存在的充分必要条件是连通图中各个点的度数都是偶数。
初始时，1号点入栈。
依次把与栈顶节点有未标记的边相连的节点入栈并递归，递归前标记这条边。
如果当前栈顶结点出发已经没有未标记边，把该节点出栈，并记录到答案序列中。
重复上述步骤直到栈为空。
倒序输出答案序列，就是一条欧拉回路。
#### 拓扑排序


### 高级图论

#### Tarjan算法

基于递归的遍历一个图中的节点关系，遍历的过程中除了要记录节点的访问状态，还要记录该节点被访问时的时间戳。
```cpp
void tarjan(int x) {
    dfn[x] = low[x] = ++num;
    s[++p] = x, v[x] = 1;
    for (int i = head[x]; i; i = next[i])
        if (!dfn[ver[i]]) {
            tarjan(ver[i]);
            low[x] = min(low[x], low[ver[i]]);
        } else if (v[ver[i]])
            low[x] = min(low[x], dfn[ver[i]]);
    if (low[x] == dfn[x]) {
        int y;
        ++t;
        do {
            y = s[p--], v[y] = 0;
            c[y] = t;
        }
        while (y != x);
    }
}

```

##### 有向图的强连通分量

如果两个顶点可以相互通达，则称两个顶点强连通。如果有向图G的每两个顶点都强连通，称G是一个强连通图。有向图的极大强连通子图，称为强连通分量。

##### 无向图的双联通分量

###### 割点
是存在于无向图中的这样的一条边，如果去掉这一条边，那么整张无向图会分为两部分，这样的一条边称为桥无向连通图中，如果删除某边后，图变成不连通，则称该边为桥。

###### 桥/割边

无向连通图中，如果删除某点后，图变成不连通，则称该点为割点。

##### 最近公共祖先

#### 匈牙利算法
```cpp
bool dfs(int x) {
    int i, y;
    for (i = head[x]; i; i = next[i])
        if (!v[y = ver[i]]) {
            v[y] = 1;
            if (!fa[y] || dfs(fa[y])) {
                fa[y] = x;
                return 1;
            }
        }
    return 0;
}

int main() {
    for (int i = 1; i <= n; i++) {
        memset(v, 0, sizeof(v));
        if (dfs(i)) ans++;
    }
}
```
##### 二分图/二部图

###### 判定是否为二分图

###### 最小覆盖

###### 最大匹配

###### 最大独立集

###### 最小路径覆盖

###### 最优匹配

###### 稳定婚姻问题
